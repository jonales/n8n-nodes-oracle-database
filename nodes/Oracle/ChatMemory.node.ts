import {
  IExecuteFunctions,
  INodeExecutionData,
  INodeType,
  INodeTypeDescription,
  NodeConnectionType,
  NodeOperationError,
} from 'n8n-workflow';
import oracledb, { Connection } from 'oracledb';

import {OracleConnectionPool} from './core';

export class OracleChatMemoryOperations {
  private executeFunctions: IExecuteFunctions;

  constructor(executeFunctions: IExecuteFunctions) {
    this.executeFunctions = executeFunctions;
  }

  async setupTable(
    connection: Connection,
    tableName: string,
  ): Promise<INodeExecutionData[]> {
    try {
      const createTableSQL = `
        BEGIN
          EXECUTE IMMEDIATE '
            CREATE TABLE ${tableName} (
              id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
              session_id VARCHAR2(255) NOT NULL,
              message_type VARCHAR2(50) NOT NULL,
              content CLOB NOT NULL,
              timestamp_created TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
              metadata CLOB,
              CONSTRAINT chk_message_type CHECK (message_type IN ('user', 'assistant', 'system'))
            )
          ';
          DBMS_OUTPUT.PUT_LINE('Tabela ${tableName} criada com sucesso');
        EXCEPTION
          WHEN OTHERS THEN
            IF SQLCODE = -955 THEN
              DBMS_OUTPUT.PUT_LINE('Tabela ${tableName} já existe');
            ELSE
              RAISE;
            END IF;
        END;
      `;

      await connection.execute(createTableSQL);

      const createIndexSQL = `
        BEGIN
          EXECUTE IMMEDIATE 'CREATE INDEX idx_${tableName}_session ON ${tableName}(session_id)';
        EXCEPTION
          WHEN OTHERS THEN
            IF SQLCODE != -955 THEN
              RAISE;
            END IF;
        END;
      `;

      await connection.execute(createIndexSQL);
      await connection.commit();

      return this.executeFunctions.helpers.returnJsonArray([
        {
          success: true,
          message: `Tabela ${tableName} configurada com sucesso`,
          operation: 'setup',
        },
      ]);
    } catch (error: unknown) {
      throw new Error(
        `Erro ao configurar tabela: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  async addMessage(
    connection: Connection,
    sessionId: string,
    tableName: string,
    memoryType: string,
  ): Promise<INodeExecutionData[]> {
    try {
      const inputData = this.executeFunctions.getInputData();
      const messageData = inputData[0]?.json;

      if (!messageData) {
        throw new Error('Nenhum dado de mensagem fornecido no input');
      }

      const content =
        messageData.content != null
          ? String(messageData.content)
          : messageData.message != null
            ? String(messageData.message)
            : JSON.stringify(messageData);

      const metadataObj =
        messageData && typeof messageData.metadata === 'object' && messageData.metadata !== null
          ? messageData.metadata
          : {};

      const metadata = JSON.stringify({
        timestamp: new Date().toISOString(),
        nodeId: this.executeFunctions.getNode().id,
        ...metadataObj,
      });

      const insertSQL = `
        INSERT INTO ${tableName} (session_id, message_type, content, metadata)
        VALUES (:sessionId, :messageType, :content, :metadata)
      `;

      const result = await connection.execute(
        insertSQL,
        {
          sessionId: String(sessionId),
          messageType: String(memoryType),
          content,
          metadata,
        },
        { autoCommit: true },
      );

      return this.executeFunctions.helpers.returnJsonArray([
        {
          success: true,
          sessionId,
          messageType: memoryType,
          content,
          rowsAffected: result.rowsAffected,
          operation: 'addMessage',
        },
      ]);
    } catch (error: unknown) {
      throw new Error(
        `Erro ao adicionar mensagem: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  async getMessages(
    connection: Connection,
    sessionId: string,
    tableName: string,
  ): Promise<INodeExecutionData[]> {
    try {
      const selectSQL = `
        SELECT
          id,
          session_id,
          message_type,
          content,
          timestamp_created,
          metadata
        FROM ${tableName}
        WHERE session_id = :sessionId
        ORDER BY timestamp_created ASC
      `;

      const result = await connection.execute(
        selectSQL,
        { sessionId },
        {
          outFormat: oracledb.OUT_FORMAT_OBJECT,
        },
      );

      const messages = (result.rows as any[]).map(row => ({
        id: row.ID,
        sessionId: row.SESSION_ID,
        messageType: row.MESSAGE_TYPE,
        content: row.CONTENT,
        timestamp: row.TIMESTAMP_CREATED,
        metadata: row.METADATA ? JSON.parse(row.METADATA) : null,
      }));

      return this.executeFunctions.helpers.returnJsonArray(messages);
    } catch (error: unknown) {
      throw new Error(
        `Erro ao recuperar mensagens: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  async clearMemory(
    connection: Connection,
    sessionId: string,
    tableName: string,
  ): Promise<INodeExecutionData[]> {
    try {
      const deleteSQL = `DELETE FROM ${tableName} WHERE session_id = :sessionId`;

      const result = await connection.execute(
        deleteSQL,
        { sessionId },
        {
          autoCommit: true,
        },
      );

      return this.executeFunctions.helpers.returnJsonArray([
        {
          success: true,
          sessionId,
          messagesDeleted: result.rowsAffected,
          operation: 'clearMemory',
        },
      ]);
    } catch (error: unknown) {
      throw new Error(
        `Erro ao limpar memória: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }

  async getSummary(
    connection: Connection,
    sessionId: string,
    tableName: string,
  ): Promise<INodeExecutionData[]> {
    try {
      const summarySQL = `
        SELECT
          COUNT(*) as total_messages,
          COUNT(CASE WHEN message_type = 'user' THEN 1 END) as user_messages,
          COUNT(CASE WHEN message_type = 'assistant' THEN 1 END) as assistant_messages,
          COUNT(CASE WHEN message_type = 'system' THEN 1 END) as system_messages,
          MIN(timestamp_created) as first_message,
          MAX(timestamp_created) as last_message
        FROM ${tableName}
        WHERE session_id = :sessionId
      `;

      const result = await connection.execute(
        summarySQL,
        { sessionId },
        {
          outFormat: oracledb.OUT_FORMAT_OBJECT,
        },
      );

      const summary = result.rows?.[0] as any;

      return this.executeFunctions.helpers.returnJsonArray([
        {
          sessionId,
          totalMessages: summary?.TOTAL_MESSAGES || 0,
          userMessages: summary?.USER_MESSAGES || 0,
          assistantMessages: summary?.ASSISTANT_MESSAGES || 0,
          systemMessages: summary?.SYSTEM_MESSAGES || 0,
          firstMessage: summary?.FIRST_MESSAGE,
          lastMessage: summary?.LAST_MESSAGE,
          operation: 'getSummary',
        },
      ]);
    } catch (error: unknown) {
      throw new Error(
        `Erro ao obter resumo: ${error instanceof Error ? error.message : String(error)}`,
      );
    }
  }
}

export class OracleChatMemory implements INodeType {
  description: INodeTypeDescription = {
    displayName: 'Oracle Chat Memory',
    name: 'oracleChatMemory',
    icon: 'file:oracle.svg',
    group: ['transform'],
    version: 1,
    description: 'Gerenciamento de memória de chat usando Oracle Database',
    defaults: {
      name: 'Oracle Chat Memory',
    },
    inputs: ['main' as NodeConnectionType],
    outputs: ['main' as NodeConnectionType],
    credentials: [
      {
        name: 'oracleCredentials',
        required: true,
      },
    ],
    properties: [
      {
        displayName: 'Operation',
        name: 'operation',
        type: 'options',
        default: 'addMessage',
        options: [
          { name: 'Setup Table', value: 'setup' },
          { name: 'Add Message', value: 'addMessage' },
          { name: 'Get Messages', value: 'getMessages' },
          { name: 'Clear Memory', value: 'clearMemory' },
          { name: 'Get Summary', value: 'getSummary' },
        ],
        description: 'Operação a ser executada',
      },
      {
        displayName: 'Session ID',
        name: 'sessionId',
        type: 'string',
        default: '',
        description: 'ID único da sessão de chat',
        displayOptions: {
          hide: {
            operation: ['setup'],
          },
        },
      },
      {
        displayName: 'Memory Type',
        name: 'memoryType',
        type: 'options',
        default: 'user',
        options: [
          { name: 'User Message', value: 'user' },
          { name: 'Assistant Message', value: 'assistant' },
          { name: 'System Message', value: 'system' },
        ],
        description: 'Tipo da mensagem',
        displayOptions: {
          show: {
            operation: ['addMessage'],
          },
        },
      },
      {
        displayName: 'Table Name',
        name: 'tableName',
        type: 'string',
        default: 'CHAT_MEMORY',
        description: 'Nome da tabela para armazenar as mensagens',
      },
    ],
  };

  async execute(this: IExecuteFunctions): Promise<INodeExecutionData[][]> {
    const credentials = await this.getCredentials('oracleCredentials');
    const operation = this.getNodeParameter('operation', 0) as string;
    const sessionId = this.getNodeParameter('sessionId', 0) as string;
    const memoryType = this.getNodeParameter('memoryType', 0) as string;
    const tableName = this.getNodeParameter('tableName', 0) as string;

    const oracleCredentials = {
      user: String(credentials.user),
      password: String(credentials.password),
      connectionString: String(credentials.connectionString),
    };

    let connection: Connection | undefined;
    let returnData: INodeExecutionData[] = [];
    const chatMemoryOps = new OracleChatMemoryOperations(this);

    try {
      const pool = await OracleConnectionPool.getPool(oracleCredentials);
      connection = await pool.getConnection();

      switch (operation) {
      case 'setup':
        returnData = await chatMemoryOps.setupTable(connection, tableName);
        break;
      case 'addMessage':
        returnData = await chatMemoryOps.addMessage(
          connection,
          sessionId,
          tableName,
          memoryType,
        );
        break;
      case 'getMessages':
        returnData = await chatMemoryOps.getMessages(connection, sessionId, tableName);
        break;
      case 'clearMemory':
        returnData = await chatMemoryOps.clearMemory(connection, sessionId, tableName);
        break;
      case 'getSummary':
        returnData = await chatMemoryOps.getSummary(connection, sessionId, tableName);
        break;
      default:
        throw new NodeOperationError(this.getNode(), `Operação "${operation}" não suportada`);
      }
    } catch (error) {
      throw new NodeOperationError(this.getNode(), `Chat Memory Error: ${error}`);
    } finally {
      if (connection) {
        await connection.close();
      }
    }

    return [returnData];
  }
}


